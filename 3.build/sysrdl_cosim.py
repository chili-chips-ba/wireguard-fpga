#!/usr/bin/python3
###################################################################
# Python script to generate WireGuard HAL co-sim adapter layer
#
# Copyright (C) 2025 Chili.CHIPS*ba
#
# options:
#   -h, --help            show this help message and exit
#   -r RDLFILE, --rdl_file RDLFILE
#                         Specify the RDL file for processing
#   -o OUTFILE, --output_file OUTFILE
#                         Specify an ouput header file
#   -v VPNODE, --vp_node VPNODE
#                         Specify VProc node number for soc_cpu (deafult 0)
#   -c, --cosim           Generate cosim header (default hardware header)
# 
###################################################################

import sys
import argparse

from systemrdl      import RDLCompiler, RDLCompileError, RDLWalker, RDLListener
from systemrdl.node import *
from datetime       import datetime

# -----------------------------------------
# Define a listener that will process the
# register model hierarchy
# -----------------------------------------

class Listener(RDLListener) :

  # -----------------------------------------
  # Constructor
  # -----------------------------------------
  def __init__(self, outfile, cosim = False, delay = 32, clkperiod = 12500, vpnode = 0):
    self.level      = 0
    self.hier_list = []
    self.new_reg   = True
    self.cosim     = cosim
    self.vpnode    = vpnode
    self.delay     = delay # cosim only
    self.clkperiod = clkperiod

    if outfile == None :
      self.out_file = "_CSR_COSIM_H_"
    else :
      self.out_file = "_" + outfile.replace('/', '_').upper() + "_"
      self.out_file = self.out_file.replace('.', '_')
      self.out_file = self.out_file.replace('-', '_')


  # -----------------------------------------
  # Generate output's file header
  # -----------------------------------------

  def __gen_header(self) :
    print("// ----------------------------------------------------------------------")
    print("// Auto-generated by sysrdl_cosim. *** DO NOT EDIT! ***")
    print("// Common WireGuard HAL header for both platform and co-simulation\n//");
    print("// Copyright (C) "+ str(datetime.now().year) + " Chili.CHIPS*ba\n//")
    print("// ----------------------------------------------------------------------")

    print("\n#ifndef " + self.out_file + " \n#define " + self.out_file + "\n");

    if self.cosim :
      print("#include <stdlib.h>")
      print("\n#ifdef __cplusplus\nextern \"C\" {\n#endif");
      print("#include \"VUser.h\"")
      print("#ifdef __cplusplus\n}\n#endif\n");
      
    print("#include \"csr.h\"\n")
    
    if self.cosim :
      print("// Definitions for co-simulation builds")
      print("#define WGMAIN                  VUserMain" + str(self.vpnode))
      print("#define NO_DELTA_UPDATE         0\n")
      print("#ifndef SOC_CPU_VPNODE\n#define SOC_CPU_VPNODE          " + str(self.vpnode) + "\n#endif\n")
      print("#ifndef SOC_CPU_CLK_PERIOD_PS\n#define SOC_CPU_CLK_PERIOD_PS   " + str(self.clkperiod) + "\n#endif\n")
    else :
      print("#define WGMAIN          main\n")

  # -----------------------------------------
  # Generate a register class header
  # -----------------------------------------
  def __gen_class_type_head (self, node, name):

    type_prefix = name[:-1].lower()
    vp_type     = type_prefix + "vp_t";
    field       = node.get_path_segment();
    
    if self.cosim :
      cast_type   = "uint64_t"
    else :
      cast_type   = type_prefix + "t*"

    print("// -----------------------------------------------------\n//");
    print("class " + vp_type + " {\npublic:")
    print("    " + vp_type + " (uint32_t* reg_addr = 0) : reg((" + cast_type + ")reg_addr) {};\n")

  # -----------------------------------------
  # Generate register class tail end
  # -----------------------------------------

  def __gen_class_type_tail (self) :

    hier_str = ""
    for h in self.hier_list :
      hier_str += h + "__"
    type_prefix = hier_str[:-1].lower()
    
    if self.cosim :
      cast_type   = "uint32_t"
    else :
      cast_type   = type_prefix + "t*"

    print("\n    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}")

    print("\nprivate:\n    " + cast_type + " reg;\n};\n")

  # -----------------------------------------
  # Process field for target
  # -----------------------------------------

  def __process_target(self, node):

    self.hier_list.append(node.type_name.upper())

    hier_str = ""
    for h in self.hier_list[:-1] :
      hier_str += h + "__"

    # Select base type based on register's width
    if node.parent.get_property("regwidth") == 64 :
      base_type = "uint64_t"
    else :
      base_type = "uint32_t"

    # Generate class head only at first field of register
    if self.new_reg :
      self.__gen_class_type_head(node, hier_str)
      reg_name = self.hier_list[-2].lower()

      # Add write and read methods for whole register
      print("    inline void     full(const " + base_type + " data) {reg->w = data;};")
      print("    inline " + base_type + " full()                    {return reg->w;};\n")

    # Add write and read methods for each field
    field_name = node.get_path_segment()
    print("    inline void     " + field_name + "(const " + base_type + " data) {reg->f." + field_name + " = data;};")
    print("    inline "+ base_type + " " + field_name + "()                    {return reg->f." + field_name + ";};")

    self.new_reg = False

    self.hier_list.pop()

  # -----------------------------------------
  # Process register for co-simulation
  # -----------------------------------------

  def __process_cosim(self, node) :

    self.hier_list.append(node.type_name.upper())

    hier_str = ""
    for h in self.hier_list[:-1] :
      hier_str += h + "__"

    # Select base type based on register's width
    if node.parent.get_property("regwidth") == 64 :
      base_type = "uint64_t"
    else :
      base_type = "uint32_t"

    # Generate class head and whole register access only at first field of register
    if self.new_reg :
      self.__gen_class_type_head(node, hier_str)
      reg_name = self.hier_list[-2].lower()

      # Add write and read methods for whole register
      if node.parent.get_property("regwidth") == 64 :
        print("    inline void     full (const " + base_type + " data) {")
        print("                        VWrite(reg, (uint32_t)(data & 0xffffffff), NO_DELTA_UPDATE, SOC_CPU_VPNODE);")
        print("                        VWrite(reg + 4, (uint32_t)((data >> 32) & 0xffffffff), NO_DELTA_UPDATE, SOC_CPU_VPNODE);")
        print("                        VTick(rand() % " + str(self.delay) + ", SOC_CPU_VPNODE);")
        print("                    };\n")
        print("    inline " + base_type + " full() {")
        print("                        uint64_t val;")
        print("                        uint32_t rdata;\n")
        print("                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE); val = rdata;")
        print("                        VRead(reg + 4, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE); val |= (uint64_t)rdata << 32;")
        print("                        VTick(rand() % " + str(self.delay) + ", SOC_CPU_VPNODE);\n")
        print("                        return val;")
        print("                    };\n")
      else :
        print("    inline void     full(const " + base_type + " data) {")
        print("                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);")
        print("                        VTick(rand() % " + str(self.delay) + ", SOC_CPU_VPNODE);")
        print("                    };\n")
        print("    inline " + base_type + " full()                    {")
        print("                        uint32_t rdata;")
        print("                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);")
        print("                        VTick(rand() % " + str(self.delay) + ", SOC_CPU_VPNODE);\n")
        print("                        return rdata;")
        print("                    };")

    # Add write and read methods for each field
    field_name = node.get_path_segment()

    # Detect if field is aligned to byte, hword or word boundary
    # and calculate byte enables. Assumes fields that aren't integer
    # multiples of a byte are padded with reserved bits to next
    # alignment to byte, hword or word. If not aligned, flag as needing
    # read-modify-write method for writes
    #
    lsb    = int(node.low)
    msb    = int(node.high)
    be     = 0xf
    rmw    = False
    if lsb < 32 :
      offset = 0
    else :
      offset = 1

    if ((msb+1 - lsb) <= 8)    and lsb%8  == 0 :
      be = 0x1 << ((lsb%32) >> 3)
    elif ((msb+1 - lsb) <= 16) and lsb%16 == 0 :
      be = 0x3 << ((lsb%32) >> 3)
    elif ((msb+1 - lsb) <= 32) and lsb%32 == 0 :
      be = 0xf
    else :
      rmw = True

    # Generate a prefix for the bit masks and bit positoin definitions
    prefix = hier_str + field_name.upper() + "_"

    # Field write method when read-modify-write
    if rmw :
      print("    inline void     " + field_name + " (const " + base_type + " data) {")
      print("                                uint32_t rdata; VRead(reg + " + str(offset*4) + ", &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);");
      print("                                " + base_type + " tmpdata = ((" + base_type + ")rdata << " + str(offset*32) + ") & ~" + prefix + "bm;")
      print("                                tmpdata |= ((data << " + prefix + "bp)" + " & " + prefix + "bm) >> " +  str(offset*32) + ";")
      print("                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);\n")
      print("                                VWriteBE(reg + " + str(offset*4) + ", wdata, " + str(hex(be)) + ", NO_DELTA_UPDATE, SOC_CPU_VPNODE);")
      print("                                VTick(rand() % " + str(self.delay) + ", SOC_CPU_VPNODE);")
      print("                      };\n")

    # Write aligned field
    else :
      print("    inline void     " + field_name + " (const " + base_type + " data) {")
      print("                        uint32_t wdata = (uint32_t)(data & 0xffffffff);\n")
      print("                        VWriteBE(reg + " + str(offset*4) + ", wdata << " + str(lsb%32) + ", "+ str(hex(be)) + ", NO_DELTA_UPDATE, SOC_CPU_VPNODE);")
      print("                        VTick(rand() % " + str(self.delay) + ", SOC_CPU_VPNODE);");
      print("                    };\n")

    # Field read method
    print("    inline "+ base_type + " " + field_name + " () {")
    print("                        uint32_t rdata;\n")
    print("                        VRead(reg + " + str(offset*4) + ", &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);");
    print("                        VTick(rand() % " + str(self.delay) + ", SOC_CPU_VPNODE);\n")
    print("                        return (((" + base_type + ")rdata << " + str(offset*32) + ") & " + prefix + "bm) >> " + prefix + "bp;")
    print("                    };\n")

    self.new_reg = False

    self.hier_list.pop()

  # -----------------------------------------
  # Callback on entering a new component
  # -----------------------------------------

  def enter_Component(self, node):

    if not isinstance(node, FieldNode):
      name = node.type_name

      if self.level :
        self.hier_list.append(name.upper())
      else :
        # Generate header output before we start
        self.__gen_header()

    self.level += 1

  # -----------------------------------------
  # Callback on entering a field
  # -----------------------------------------

  def enter_Field(self, node):

    if self.cosim :
      self.__process_cosim(node)
    else :
      self.__process_target(node)

  # -----------------------------------------
  # Callback on exiting a component
  # -----------------------------------------

  def exit_Component(self, node):

    if not isinstance(node, FieldNode) and self.level > 1:
    
      default_addr = ""
      if self.level == 2 :
        default_addr = " = (uint32_t*)" + hex(node.absolute_address)

      if not self.new_reg :
        self.__gen_class_type_tail()

      self.new_reg = True

      hier_str = ""
      for h in self.hier_list[:-1] :
        hier_str += h + "__"

      # Only process hierarchical blocks in the exit callback
      if not isinstance(node, RegNode) :

        # Get the name of this segment and remove "[]" if an array
        name = node.get_path_segment()
        if node.is_array :
          name = name[:-2]

        # Get the VProc type for this segment
        type = hier_str.lower() + node.type_name + "_vp_t"

        # Print class opening definition
        print ("// -----------------------------------------------------")
        print("class " + type + " {\npublic:\n")

        # Initialise a list for the size of elements so far processed
        size_list = []

        # Initialise a list for the member pointer definitions
        ptr_list  = []

        # Generate the constructor
        print("    " + type + "(uint32_t* base_addr" + default_addr + ")\n    {")

        # Go through the child nodes one at a time
        for child in node.children() :

          child_name      = child.get_path_segment()
          child_type      = child.type_name
          type_prefix     = type[:-4]

          if child.is_array :

            # Check array dimensions
            if len(child.array_dimensions) != 1 :
              sys.exit("***ERROR: encountered array dimension > 1. Not supported")

            child_name      = child_name[:-2]
            array_dimension = str(child.array_dimensions[0])

            print("        for(int idx = 0; idx < " + array_dimension + "; idx++)\n        {")
            print("            " + child_name + "[idx] = new " + type_prefix + "_" + child_type + "_vp_t (base_addr +")
            if size_list :
              for element in size_list :
                print("                                                                                   " + element + " +");
            print("                                                                                   idx * sizeof(" + type_prefix + "_" + child_type + "_t)/4);")
            print("        };\n")

            size_list.append(array_dimension + "*sizeof(" + type_prefix + "_" + child_type + "_t)/4")
            ptr_list.append("    " + type_prefix + "_" + child_type + "_vp_t* " + child_name + "[" + array_dimension + "];")

          else :

            print("        " + child_name +" = new " + type_prefix + "_" + child_type + "_vp_t (base_addr", end='')
            if size_list :
              print(" +")
              for element in size_list :
                print("                                                                                   " + element, end='');
                if element == size_list[-1] :
                  print('')
                else :
                  print(" + ")
              print("                                                                                    );")
            else:
              print(");")

            size_list.append("sizeof(" + type_prefix + "_" + child_type + "_t)/4")
            ptr_list.append("    " + type_prefix + "_" + child_type + "_vp_t* " + child_name + ";")

        print("    };\n")

        # Generate the pointer declarations
        if ptr_list :
          for ptr in ptr_list :
            print(ptr)

        print("} ;\n")

      if self.hier_list:
        self.hier_list.pop()

    self.level -= 1

# end Listener class

# -------------------------------------------
# Parse the command line arguments
# -------------------------------------------

def processCmdLine():

    # Create a parser object
    parser = argparse.ArgumentParser(description='Process command line options.')

    # Specific command line options added here
    parser.add_argument('-r', '--rdl_file',    dest='rdlFile',   default='csrSw.rdl', action='store',      help='Specify the RDL file for processing')
    parser.add_argument('-o', '--output_file', dest='outFile',   default=None,        action='store',      help='Specify an ouput header file')
    parser.add_argument('-c', '--cosim',       dest='cosim',     default=False,       action='store_true', help='Generate cosim header')
    parser.add_argument('-v', '--vp_node',     dest='vpnode',    default=0,           action='store',      help='Specify VProc node number for soc_cpu (cosim only)')
    parser.add_argument('-d', '--delay_range', dest='delay',     default=32,          action='store',      help='Specify maximum delay between transactions (cosim only)')
    parser.add_argument('-C', '--clk_period',  dest='clkperiod', default=18518,       action='store',      help='Specify the VProc soc_cpu clock period in ps (cosim only)')

    return parser.parse_args()

#############################################
# MAIN
#############################################

if __name__ == "__main__":

    # Process the command line options
    cmdArgs = processCmdLine()

    # If an output file is specified, redirect stdout to that file
    save_stdout = sys.stdout
    f = sys.stdout
    if cmdArgs.outFile != None :
      f = open(cmdArgs.outFile, "w")
      sys.stdout = f

    # Collect input files from the command line arguments
    rdl_file = cmdArgs.rdlFile

    # Create an instance of the compiler
    rdlc = RDLCompiler()

    try:
        # Compile the RDL file
        rdlc.compile_file(rdl_file)

        # Elaborate the design
        root = rdlc.elaborate()
    except RDLCompileError:
        # A compilation error occurred. Exit with error code
        sys.exit(1)

    # Traverse the register model!
    walker   = RDLWalker(unroll=False)
    listener = Listener(cmdArgs.outFile, cmdArgs.cosim, cmdArgs.delay + 1, cmdArgs.clkperiod, cmdArgs.vpnode)

    walker.walk(root, listener)

    print("\n#endif")

    if cmdArgs.outFile != None :
      sys.stdout = save_stdout
      f.close()
