// ----------------------------------------------------------------------
// Auto-generated by sysrdl_cosim. *** DO NOT EDIT! ***
// Common WireGuard HAL header for both platform and co-simulation
//
// Copyright (C) 2026 Chili.CHIPS*ba
//
// ----------------------------------------------------------------------

#ifndef _CSR_BUILD_GENERATED_FILES_CSR_COSIM_H_ 
#define _CSR_BUILD_GENERATED_FILES_CSR_COSIM_H_

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif
#include "VUser.h"
#ifdef __cplusplus
}
#endif

#include "csr.h"

// Definitions for co-simulation builds
#define WGMAIN                  VUserMain0
#define NO_DELTA_UPDATE         0

#ifndef SOC_CPU_VPNODE
#define SOC_CPU_VPNODE          0
#endif

#ifndef SOC_CPU_CLK_PERIOD_PS
#define SOC_CPU_CLK_PERIOD_PS   18518
#endif

// -----------------------------------------------------
class imem_vp_t {
public:

    imem_vp_t(uint32_t* base_addr = (uint32_t*)0x0)
    {
    };

} ;

// -----------------------------------------------------
class dmem_vp_t {
public:

    dmem_vp_t(uint32_t* base_addr = (uint32_t*)0x10000000)
    {
    };

} ;

// -----------------------------------------------------
//
class csr__cpu_fifo__rx__data_31_0_vp_t {
public:
    csr__cpu_fifo__rx__data_31_0_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tdata (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tdata () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__RX__DATA_31_0__TDATA_bm) >> CSR__CPU_FIFO__RX__DATA_31_0__TDATA_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cpu_fifo__rx__data_63_32_vp_t {
public:
    csr__cpu_fifo__rx__data_63_32_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tdata (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tdata () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__RX__DATA_63_32__TDATA_bm) >> CSR__CPU_FIFO__RX__DATA_63_32__TDATA_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cpu_fifo__rx__data_95_64_vp_t {
public:
    csr__cpu_fifo__rx__data_95_64_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tdata (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tdata () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__RX__DATA_95_64__TDATA_bm) >> CSR__CPU_FIFO__RX__DATA_95_64__TDATA_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cpu_fifo__rx__data_127_96_vp_t {
public:
    csr__cpu_fifo__rx__data_127_96_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tdata (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tdata () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__RX__DATA_127_96__TDATA_bm) >> CSR__CPU_FIFO__RX__DATA_127_96__TDATA_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cpu_fifo__rx__control_vp_t {
public:
    csr__cpu_fifo__rx__control_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tuser_dst (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tuser_dst () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__RX__CONTROL__TUSER_DST_bm) >> CSR__CPU_FIFO__RX__CONTROL__TUSER_DST_bp;
                    };

    inline void     tuser_src (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__CPU_FIFO__RX__CONTROL__TUSER_SRC_bm;
                                tmpdata |= ((data << CSR__CPU_FIFO__RX__CONTROL__TUSER_SRC_bp) & CSR__CPU_FIFO__RX__CONTROL__TUSER_SRC_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t tuser_src () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__RX__CONTROL__TUSER_SRC_bm) >> CSR__CPU_FIFO__RX__CONTROL__TUSER_SRC_bp;
                    };

    inline void     tuser_bypass_stage (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__CPU_FIFO__RX__CONTROL__TUSER_BYPASS_STAGE_bm;
                                tmpdata |= ((data << CSR__CPU_FIFO__RX__CONTROL__TUSER_BYPASS_STAGE_bp) & CSR__CPU_FIFO__RX__CONTROL__TUSER_BYPASS_STAGE_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t tuser_bypass_stage () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__RX__CONTROL__TUSER_BYPASS_STAGE_bm) >> CSR__CPU_FIFO__RX__CONTROL__TUSER_BYPASS_STAGE_bp;
                    };

    inline void     tuser_bypass_all (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__CPU_FIFO__RX__CONTROL__TUSER_BYPASS_ALL_bm;
                                tmpdata |= ((data << CSR__CPU_FIFO__RX__CONTROL__TUSER_BYPASS_ALL_bp) & CSR__CPU_FIFO__RX__CONTROL__TUSER_BYPASS_ALL_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t tuser_bypass_all () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__RX__CONTROL__TUSER_BYPASS_ALL_bm) >> CSR__CPU_FIFO__RX__CONTROL__TUSER_BYPASS_ALL_bp;
                    };

    inline void     tlast (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__CPU_FIFO__RX__CONTROL__TLAST_bm;
                                tmpdata |= ((data << CSR__CPU_FIFO__RX__CONTROL__TLAST_bp) & CSR__CPU_FIFO__RX__CONTROL__TLAST_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t tlast () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__RX__CONTROL__TLAST_bm) >> CSR__CPU_FIFO__RX__CONTROL__TLAST_bp;
                    };

    inline void     tkeep (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 16, 0xc, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tkeep () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__RX__CONTROL__TKEEP_bm) >> CSR__CPU_FIFO__RX__CONTROL__TKEEP_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cpu_fifo__rx__trigger_vp_t {
public:
    csr__cpu_fifo__rx__trigger_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tvalid (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tvalid () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__RX__TRIGGER__TVALID_bm) >> CSR__CPU_FIFO__RX__TRIGGER__TVALID_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cpu_fifo__rx__status_vp_t {
public:
    csr__cpu_fifo__rx__status_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tready (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tready () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__RX__STATUS__TREADY_bm) >> CSR__CPU_FIFO__RX__STATUS__TREADY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
class csr__cpu_fifo__rx_vp_t {
public:

    csr__cpu_fifo__rx_vp_t(uint32_t* base_addr)
    {
        data_31_0 = new csr__cpu_fifo__rx__data_31_0_vp_t (base_addr + 0x0/4);
        data_63_32 = new csr__cpu_fifo__rx__data_63_32_vp_t (base_addr + 0x4/4);
        data_95_64 = new csr__cpu_fifo__rx__data_95_64_vp_t (base_addr + 0x8/4);
        data_127_96 = new csr__cpu_fifo__rx__data_127_96_vp_t (base_addr + 0xc/4);
        control = new csr__cpu_fifo__rx__control_vp_t (base_addr + 0x10/4);
        trigger = new csr__cpu_fifo__rx__trigger_vp_t (base_addr + 0x14/4);
        status = new csr__cpu_fifo__rx__status_vp_t (base_addr + 0x18/4);
    };

    csr__cpu_fifo__rx__data_31_0_vp_t* data_31_0;
    csr__cpu_fifo__rx__data_63_32_vp_t* data_63_32;
    csr__cpu_fifo__rx__data_95_64_vp_t* data_95_64;
    csr__cpu_fifo__rx__data_127_96_vp_t* data_127_96;
    csr__cpu_fifo__rx__control_vp_t* control;
    csr__cpu_fifo__rx__trigger_vp_t* trigger;
    csr__cpu_fifo__rx__status_vp_t* status;
} ;

// -----------------------------------------------------
//
class csr__cpu_fifo__tx__data_31_0_vp_t {
public:
    csr__cpu_fifo__tx__data_31_0_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tdata (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tdata () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__TX__DATA_31_0__TDATA_bm) >> CSR__CPU_FIFO__TX__DATA_31_0__TDATA_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cpu_fifo__tx__data_63_32_vp_t {
public:
    csr__cpu_fifo__tx__data_63_32_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tdata (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tdata () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__TX__DATA_63_32__TDATA_bm) >> CSR__CPU_FIFO__TX__DATA_63_32__TDATA_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cpu_fifo__tx__data_95_64_vp_t {
public:
    csr__cpu_fifo__tx__data_95_64_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tdata (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tdata () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__TX__DATA_95_64__TDATA_bm) >> CSR__CPU_FIFO__TX__DATA_95_64__TDATA_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cpu_fifo__tx__data_127_96_vp_t {
public:
    csr__cpu_fifo__tx__data_127_96_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tdata (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tdata () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__TX__DATA_127_96__TDATA_bm) >> CSR__CPU_FIFO__TX__DATA_127_96__TDATA_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cpu_fifo__tx__control_vp_t {
public:
    csr__cpu_fifo__tx__control_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tuser_dst (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tuser_dst () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__TX__CONTROL__TUSER_DST_bm) >> CSR__CPU_FIFO__TX__CONTROL__TUSER_DST_bp;
                    };

    inline void     tuser_src (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__CPU_FIFO__TX__CONTROL__TUSER_SRC_bm;
                                tmpdata |= ((data << CSR__CPU_FIFO__TX__CONTROL__TUSER_SRC_bp) & CSR__CPU_FIFO__TX__CONTROL__TUSER_SRC_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t tuser_src () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__TX__CONTROL__TUSER_SRC_bm) >> CSR__CPU_FIFO__TX__CONTROL__TUSER_SRC_bp;
                    };

    inline void     tuser_bypass_stage (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__CPU_FIFO__TX__CONTROL__TUSER_BYPASS_STAGE_bm;
                                tmpdata |= ((data << CSR__CPU_FIFO__TX__CONTROL__TUSER_BYPASS_STAGE_bp) & CSR__CPU_FIFO__TX__CONTROL__TUSER_BYPASS_STAGE_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t tuser_bypass_stage () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__TX__CONTROL__TUSER_BYPASS_STAGE_bm) >> CSR__CPU_FIFO__TX__CONTROL__TUSER_BYPASS_STAGE_bp;
                    };

    inline void     tuser_bypass_all (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__CPU_FIFO__TX__CONTROL__TUSER_BYPASS_ALL_bm;
                                tmpdata |= ((data << CSR__CPU_FIFO__TX__CONTROL__TUSER_BYPASS_ALL_bp) & CSR__CPU_FIFO__TX__CONTROL__TUSER_BYPASS_ALL_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t tuser_bypass_all () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__TX__CONTROL__TUSER_BYPASS_ALL_bm) >> CSR__CPU_FIFO__TX__CONTROL__TUSER_BYPASS_ALL_bp;
                    };

    inline void     tlast (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__CPU_FIFO__TX__CONTROL__TLAST_bm;
                                tmpdata |= ((data << CSR__CPU_FIFO__TX__CONTROL__TLAST_bp) & CSR__CPU_FIFO__TX__CONTROL__TLAST_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t tlast () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__TX__CONTROL__TLAST_bm) >> CSR__CPU_FIFO__TX__CONTROL__TLAST_bp;
                    };

    inline void     tkeep (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 16, 0xc, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tkeep () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__TX__CONTROL__TKEEP_bm) >> CSR__CPU_FIFO__TX__CONTROL__TKEEP_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cpu_fifo__tx__trigger_vp_t {
public:
    csr__cpu_fifo__tx__trigger_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tready (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tready () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__TX__TRIGGER__TREADY_bm) >> CSR__CPU_FIFO__TX__TRIGGER__TREADY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cpu_fifo__tx__status_vp_t {
public:
    csr__cpu_fifo__tx__status_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     tvalid (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t tvalid () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CPU_FIFO__TX__STATUS__TVALID_bm) >> CSR__CPU_FIFO__TX__STATUS__TVALID_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
class csr__cpu_fifo__tx_vp_t {
public:

    csr__cpu_fifo__tx_vp_t(uint32_t* base_addr)
    {
        data_31_0 = new csr__cpu_fifo__tx__data_31_0_vp_t (base_addr + 0x0/4);
        data_63_32 = new csr__cpu_fifo__tx__data_63_32_vp_t (base_addr + 0x4/4);
        data_95_64 = new csr__cpu_fifo__tx__data_95_64_vp_t (base_addr + 0x8/4);
        data_127_96 = new csr__cpu_fifo__tx__data_127_96_vp_t (base_addr + 0xc/4);
        control = new csr__cpu_fifo__tx__control_vp_t (base_addr + 0x10/4);
        trigger = new csr__cpu_fifo__tx__trigger_vp_t (base_addr + 0x14/4);
        status = new csr__cpu_fifo__tx__status_vp_t (base_addr + 0x18/4);
    };

    csr__cpu_fifo__tx__data_31_0_vp_t* data_31_0;
    csr__cpu_fifo__tx__data_63_32_vp_t* data_63_32;
    csr__cpu_fifo__tx__data_95_64_vp_t* data_95_64;
    csr__cpu_fifo__tx__data_127_96_vp_t* data_127_96;
    csr__cpu_fifo__tx__control_vp_t* control;
    csr__cpu_fifo__tx__trigger_vp_t* trigger;
    csr__cpu_fifo__tx__status_vp_t* status;
} ;

// -----------------------------------------------------
class csr__cpu_fifo_vp_t {
public:

    csr__cpu_fifo_vp_t(uint32_t* base_addr)
    {
        rx = new csr__cpu_fifo__rx_vp_t (base_addr + 0x0/4);
        tx = new csr__cpu_fifo__tx_vp_t (base_addr + 0x1c/4);
    };

    csr__cpu_fifo__rx_vp_t* rx;
    csr__cpu_fifo__tx_vp_t* tx;
} ;

// -----------------------------------------------------
//
class csr__uart__rx_vp_t {
public:
    csr__uart__rx_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     data (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t data () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__RX__DATA_bm) >> CSR__UART__RX__DATA_bp;
                    };

    inline void     oflow (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__UART__RX__OFLOW_bm;
                                tmpdata |= ((data << CSR__UART__RX__OFLOW_bp) & CSR__UART__RX__OFLOW_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t oflow () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__RX__OFLOW_bm) >> CSR__UART__RX__OFLOW_bp;
                    };

    inline void     valid (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__UART__RX__VALID_bm;
                                tmpdata |= ((data << CSR__UART__RX__VALID_bp) & CSR__UART__RX__VALID_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t valid () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__RX__VALID_bm) >> CSR__UART__RX__VALID_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__uart__rx_trigger_read_2925067f_vp_t {
public:
    csr__uart__rx_trigger_read_2925067f_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     read (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t read () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__RX_TRIGGER_READ_2925067F__READ_bm) >> CSR__UART__RX_TRIGGER_READ_2925067F__READ_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__uart__tx_vp_t {
public:
    csr__uart__tx_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     data (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t data () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__TX__DATA_bm) >> CSR__UART__TX__DATA_bp;
                    };

    inline void     busy (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__UART__TX__BUSY_bm;
                                tmpdata |= ((data << CSR__UART__TX__BUSY_bp) & CSR__UART__TX__BUSY_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t busy () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__TX__BUSY_bm) >> CSR__UART__TX__BUSY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__uart__tx_trigger_write_d2a2fe0e_vp_t {
public:
    csr__uart__tx_trigger_write_d2a2fe0e_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     write (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t write () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__UART__TX_TRIGGER_WRITE_D2A2FE0E__WRITE_bm) >> CSR__UART__TX_TRIGGER_WRITE_D2A2FE0E__WRITE_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
class csr__uart_vp_t {
public:

    csr__uart_vp_t(uint32_t* base_addr)
    {
        rx = new csr__uart__rx_vp_t (base_addr + 0x0/4);
        rx_trigger = new csr__uart__rx_trigger_read_2925067f_vp_t (base_addr + 0x4/4);
        tx = new csr__uart__tx_vp_t (base_addr + 0x8/4);
        tx_trigger = new csr__uart__tx_trigger_write_d2a2fe0e_vp_t (base_addr + 0xc/4);
    };

    csr__uart__rx_vp_t* rx;
    csr__uart__rx_trigger_read_2925067f_vp_t* rx_trigger;
    csr__uart__tx_vp_t* tx;
    csr__uart__tx_trigger_write_d2a2fe0e_vp_t* tx_trigger;
} ;

// -----------------------------------------------------
//
class csr__gpio_vp_t {
public:
    csr__gpio_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key1 (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key1 () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__GPIO__KEY1_bm) >> CSR__GPIO__KEY1_bp;
                    };

    inline void     key2 (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__GPIO__KEY2_bm;
                                tmpdata |= ((data << CSR__GPIO__KEY2_bp) & CSR__GPIO__KEY2_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t key2 () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__GPIO__KEY2_bm) >> CSR__GPIO__KEY2_bp;
                    };

    inline void     led1 (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 8, 0x2, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t led1 () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__GPIO__LED1_bm) >> CSR__GPIO__LED1_bp;
                    };

    inline void     led2 (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__GPIO__LED2_bm;
                                tmpdata |= ((data << CSR__GPIO__LED2_bp) & CSR__GPIO__LED2_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t led2 () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__GPIO__LED2_bm) >> CSR__GPIO__LED2_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__ethernet__status_vp_t {
public:
    csr__ethernet__status_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     speed (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t speed () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__ETHERNET__STATUS__SPEED_bm) >> CSR__ETHERNET__STATUS__SPEED_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__ethernet__mac_47_32_vp_t {
public:
    csr__ethernet__mac_47_32_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     mac (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x3, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t mac () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__ETHERNET__MAC_47_32__MAC_bm) >> CSR__ETHERNET__MAC_47_32__MAC_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__ethernet__mac_31_0_vp_t {
public:
    csr__ethernet__mac_31_0_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     mac (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t mac () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__ETHERNET__MAC_31_0__MAC_bm) >> CSR__ETHERNET__MAC_31_0__MAC_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
class csr__ethernet_vp_t {
public:

    csr__ethernet_vp_t(uint32_t* base_addr)
    {
        status = new csr__ethernet__status_vp_t (base_addr + 0x0/4);
        mac_47_32 = new csr__ethernet__mac_47_32_vp_t (base_addr + 0x4/4);
        mac_31_0 = new csr__ethernet__mac_31_0_vp_t (base_addr + 0x8/4);
    };

    csr__ethernet__status_vp_t* status;
    csr__ethernet__mac_47_32_vp_t* mac_47_32;
    csr__ethernet__mac_31_0_vp_t* mac_31_0;
} ;

// -----------------------------------------------------
//
class csr__hw_id_vp_t {
public:
    csr__hw_id_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     PRODUCT (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x3, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t PRODUCT () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__HW_ID__PRODUCT_bm) >> CSR__HW_ID__PRODUCT_bp;
                    };

    inline void     VENDOR (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 16, 0xc, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t VENDOR () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__HW_ID__VENDOR_bm) >> CSR__HW_ID__VENDOR_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__hw_version_vp_t {
public:
    csr__hw_version_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     PATCH (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x3, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t PATCH () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__HW_VERSION__PATCH_bm) >> CSR__HW_VERSION__PATCH_bp;
                    };

    inline void     MINOR (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 16, 0x4, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t MINOR () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__HW_VERSION__MINOR_bm) >> CSR__HW_VERSION__MINOR_bp;
                    };

    inline void     MAJOR (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 24, 0x8, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t MAJOR () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__HW_VERSION__MAJOR_bm) >> CSR__HW_VERSION__MAJOR_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__dpe__fcr_vp_t {
public:
    csr__dpe__fcr_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     idle (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t idle () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__DPE__FCR__IDLE_bm) >> CSR__DPE__FCR__IDLE_bp;
                    };

    inline void     pause (const uint32_t data) {
                                uint32_t rdata; VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                uint32_t tmpdata = ((uint32_t)rdata << 0) & ~CSR__DPE__FCR__PAUSE_bm;
                                tmpdata |= ((data << CSR__DPE__FCR__PAUSE_bp) & CSR__DPE__FCR__PAUSE_bm) >> 0;
                                uint32_t wdata = (uint32_t)(tmpdata & 0xffffffff);

                                VWriteBE(reg + 0, wdata, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                                VTick(rand() % 33, SOC_CPU_VPNODE);
                      };

    inline uint32_t pause () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__DPE__FCR__PAUSE_bm) >> CSR__DPE__FCR__PAUSE_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
class csr__dpe_vp_t {
public:

    csr__dpe_vp_t(uint32_t* base_addr)
    {
        fcr = new csr__dpe__fcr_vp_t (base_addr + 0x0/4);
    };

    csr__dpe__fcr_vp_t* fcr;
} ;

// -----------------------------------------------------
//
class csr__routing_table__entry__ip_vp_t {
public:
    csr__routing_table__entry__ip_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     ip (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t ip () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__ROUTING_TABLE__ENTRY__IP__IP_bm) >> CSR__ROUTING_TABLE__ENTRY__IP__IP_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__routing_table__entry__mask_vp_t {
public:
    csr__routing_table__entry__mask_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     mask (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t mask () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__ROUTING_TABLE__ENTRY__MASK__MASK_bm) >> CSR__ROUTING_TABLE__ENTRY__MASK__MASK_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__routing_table__entry__peer_idx_vp_t {
public:
    csr__routing_table__entry__peer_idx_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     peer_idx (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t peer_idx () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__ROUTING_TABLE__ENTRY__PEER_IDX__PEER_IDX_bm) >> CSR__ROUTING_TABLE__ENTRY__PEER_IDX__PEER_IDX_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__routing_table__entry__dst_vp_t {
public:
    csr__routing_table__entry__dst_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     dst (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x1, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t dst () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__ROUTING_TABLE__ENTRY__DST__DST_bm) >> CSR__ROUTING_TABLE__ENTRY__DST__DST_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
class csr__routing_table__entry_vp_t {
public:

    csr__routing_table__entry_vp_t(uint32_t* base_addr)
    {
        ip = new csr__routing_table__entry__ip_vp_t (base_addr + 0x0/4);
        mask = new csr__routing_table__entry__mask_vp_t (base_addr + 0x4/4);
        peer_idx = new csr__routing_table__entry__peer_idx_vp_t (base_addr + 0x8/4);
        dst = new csr__routing_table__entry__dst_vp_t (base_addr + 0xc/4);
    };

    csr__routing_table__entry__ip_vp_t* ip;
    csr__routing_table__entry__mask_vp_t* mask;
    csr__routing_table__entry__peer_idx_vp_t* peer_idx;
    csr__routing_table__entry__dst_vp_t* dst;
} ;

// -----------------------------------------------------
class csr__routing_table_vp_t {
public:

    csr__routing_table_vp_t(uint32_t* base_addr)
    {
        for(int idx = 0; idx < 64; idx++)
        {
            entry[idx] = new csr__routing_table__entry_vp_t (base_addr + 0x0/4 + 
                                                                                   idx * sizeof(csr__routing_table__entry_t)/4);
        };

    };

    csr__routing_table__entry_vp_t* entry[64];
} ;

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__local_mac_47_32_vp_t {
public:
    csr__cryptokey_table__entry__local_mac_47_32_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     mac (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x3, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t mac () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__LOCAL_MAC_47_32__MAC_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__LOCAL_MAC_47_32__MAC_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__local_mac_31_0_vp_t {
public:
    csr__cryptokey_table__entry__local_mac_31_0_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     mac (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t mac () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__LOCAL_MAC_31_0__MAC_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__LOCAL_MAC_31_0__MAC_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__local_ip_vp_t {
public:
    csr__cryptokey_table__entry__local_ip_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     ip (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t ip () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__LOCAL_IP__IP_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__LOCAL_IP__IP_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__local_port_vp_t {
public:
    csr__cryptokey_table__entry__local_port_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     port (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x3, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t port () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__LOCAL_PORT__PORT_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__LOCAL_PORT__PORT_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__local_id_vp_t {
public:
    csr__cryptokey_table__entry__local_id_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     id (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t id () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__LOCAL_ID__ID_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__LOCAL_ID__ID_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__remote_mac_47_32_vp_t {
public:
    csr__cryptokey_table__entry__remote_mac_47_32_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     mac (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x3, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t mac () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__REMOTE_MAC_47_32__MAC_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__REMOTE_MAC_47_32__MAC_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__remote_mac_31_0_vp_t {
public:
    csr__cryptokey_table__entry__remote_mac_31_0_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     mac (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t mac () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__REMOTE_MAC_31_0__MAC_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__REMOTE_MAC_31_0__MAC_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__remote_ip_vp_t {
public:
    csr__cryptokey_table__entry__remote_ip_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     ip (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t ip () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__REMOTE_IP__IP_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__REMOTE_IP__IP_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__remote_port_vp_t {
public:
    csr__cryptokey_table__entry__remote_port_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     port (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0x3, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t port () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__REMOTE_PORT__PORT_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__REMOTE_PORT__PORT_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__remote_id_vp_t {
public:
    csr__cryptokey_table__entry__remote_id_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     id (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t id () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__REMOTE_ID__ID_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__REMOTE_ID__ID_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__encrypt_key_255_224_vp_t {
public:
    csr__cryptokey_table__entry__encrypt_key_255_224_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_255_224__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_255_224__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__encrypt_key_223_192_vp_t {
public:
    csr__cryptokey_table__entry__encrypt_key_223_192_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_223_192__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_223_192__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__encrypt_key_191_160_vp_t {
public:
    csr__cryptokey_table__entry__encrypt_key_191_160_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_191_160__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_191_160__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__encrypt_key_159_128_vp_t {
public:
    csr__cryptokey_table__entry__encrypt_key_159_128_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_159_128__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_159_128__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__encrypt_key_127_96_vp_t {
public:
    csr__cryptokey_table__entry__encrypt_key_127_96_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_127_96__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_127_96__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__encrypt_key_95_64_vp_t {
public:
    csr__cryptokey_table__entry__encrypt_key_95_64_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_95_64__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_95_64__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__encrypt_key_63_32_vp_t {
public:
    csr__cryptokey_table__entry__encrypt_key_63_32_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_63_32__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_63_32__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__encrypt_key_31_0_vp_t {
public:
    csr__cryptokey_table__entry__encrypt_key_31_0_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_31_0__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__ENCRYPT_KEY_31_0__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__decrypt_key_255_224_vp_t {
public:
    csr__cryptokey_table__entry__decrypt_key_255_224_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_255_224__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_255_224__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__decrypt_key_223_192_vp_t {
public:
    csr__cryptokey_table__entry__decrypt_key_223_192_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_223_192__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_223_192__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__decrypt_key_191_160_vp_t {
public:
    csr__cryptokey_table__entry__decrypt_key_191_160_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_191_160__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_191_160__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__decrypt_key_159_128_vp_t {
public:
    csr__cryptokey_table__entry__decrypt_key_159_128_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_159_128__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_159_128__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__decrypt_key_127_96_vp_t {
public:
    csr__cryptokey_table__entry__decrypt_key_127_96_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_127_96__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_127_96__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__decrypt_key_95_64_vp_t {
public:
    csr__cryptokey_table__entry__decrypt_key_95_64_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_95_64__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_95_64__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__decrypt_key_63_32_vp_t {
public:
    csr__cryptokey_table__entry__decrypt_key_63_32_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_63_32__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_63_32__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__decrypt_key_31_0_vp_t {
public:
    csr__cryptokey_table__entry__decrypt_key_31_0_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     key (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t key () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_31_0__KEY_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__DECRYPT_KEY_31_0__KEY_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__send_cnt_63_32_vp_t {
public:
    csr__cryptokey_table__entry__send_cnt_63_32_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     cnt (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t cnt () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__SEND_CNT_63_32__CNT_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__SEND_CNT_63_32__CNT_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__send_cnt_31_0_vp_t {
public:
    csr__cryptokey_table__entry__send_cnt_31_0_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     cnt (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t cnt () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__SEND_CNT_31_0__CNT_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__SEND_CNT_31_0__CNT_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__recv_cnt_63_32_vp_t {
public:
    csr__cryptokey_table__entry__recv_cnt_63_32_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     cnt (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t cnt () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__RECV_CNT_63_32__CNT_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__RECV_CNT_63_32__CNT_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
//
class csr__cryptokey_table__entry__recv_cnt_31_0_vp_t {
public:
    csr__cryptokey_table__entry__recv_cnt_31_0_vp_t (uint32_t* reg_addr = 0) : reg((uint64_t)reg_addr) {};

    inline void     full(const uint32_t data) {
                        VWrite(reg, data, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t full()                    {
                        uint32_t rdata;
                        VRead(reg, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return rdata;
                    };
    inline void     cnt (const uint32_t data) {
                        uint32_t wdata = (uint32_t)(data & 0xffffffff);

                        VWriteBE(reg + 0, wdata << 0, 0xf, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);
                    };

    inline uint32_t cnt () {
                        uint32_t rdata;

                        VRead(reg + 0, &rdata, NO_DELTA_UPDATE, SOC_CPU_VPNODE);
                        VTick(rand() % 33, SOC_CPU_VPNODE);

                        return (((uint32_t)rdata << 0) & CSR__CRYPTOKEY_TABLE__ENTRY__RECV_CNT_31_0__CNT_bm) >> CSR__CRYPTOKEY_TABLE__ENTRY__RECV_CNT_31_0__CNT_bp;
                    };


    inline uint32_t* get_addr() {return (uint32_t*)((uint64_t)reg);}

private:
    uint32_t reg;
};

// -----------------------------------------------------
class csr__cryptokey_table__entry_vp_t {
public:

    csr__cryptokey_table__entry_vp_t(uint32_t* base_addr)
    {
        local_mac_47_32 = new csr__cryptokey_table__entry__local_mac_47_32_vp_t (base_addr + 0x0/4);
        local_mac_31_0 = new csr__cryptokey_table__entry__local_mac_31_0_vp_t (base_addr + 0x4/4);
        local_ip = new csr__cryptokey_table__entry__local_ip_vp_t (base_addr + 0x8/4);
        local_port = new csr__cryptokey_table__entry__local_port_vp_t (base_addr + 0xc/4);
        local_id = new csr__cryptokey_table__entry__local_id_vp_t (base_addr + 0x10/4);
        remote_mac_47_32 = new csr__cryptokey_table__entry__remote_mac_47_32_vp_t (base_addr + 0x14/4);
        remote_mac_31_0 = new csr__cryptokey_table__entry__remote_mac_31_0_vp_t (base_addr + 0x18/4);
        remote_ip = new csr__cryptokey_table__entry__remote_ip_vp_t (base_addr + 0x1c/4);
        remote_port = new csr__cryptokey_table__entry__remote_port_vp_t (base_addr + 0x20/4);
        remote_id = new csr__cryptokey_table__entry__remote_id_vp_t (base_addr + 0x24/4);
        encrypt_key_255_224 = new csr__cryptokey_table__entry__encrypt_key_255_224_vp_t (base_addr + 0x28/4);
        encrypt_key_223_192 = new csr__cryptokey_table__entry__encrypt_key_223_192_vp_t (base_addr + 0x2c/4);
        encrypt_key_191_160 = new csr__cryptokey_table__entry__encrypt_key_191_160_vp_t (base_addr + 0x30/4);
        encrypt_key_159_128 = new csr__cryptokey_table__entry__encrypt_key_159_128_vp_t (base_addr + 0x34/4);
        encrypt_key_127_96 = new csr__cryptokey_table__entry__encrypt_key_127_96_vp_t (base_addr + 0x38/4);
        encrypt_key_95_64 = new csr__cryptokey_table__entry__encrypt_key_95_64_vp_t (base_addr + 0x3c/4);
        encrypt_key_63_32 = new csr__cryptokey_table__entry__encrypt_key_63_32_vp_t (base_addr + 0x40/4);
        encrypt_key_31_0 = new csr__cryptokey_table__entry__encrypt_key_31_0_vp_t (base_addr + 0x44/4);
        decrypt_key_255_224 = new csr__cryptokey_table__entry__decrypt_key_255_224_vp_t (base_addr + 0x48/4);
        decrypt_key_223_192 = new csr__cryptokey_table__entry__decrypt_key_223_192_vp_t (base_addr + 0x4c/4);
        decrypt_key_191_160 = new csr__cryptokey_table__entry__decrypt_key_191_160_vp_t (base_addr + 0x50/4);
        decrypt_key_159_128 = new csr__cryptokey_table__entry__decrypt_key_159_128_vp_t (base_addr + 0x54/4);
        decrypt_key_127_96 = new csr__cryptokey_table__entry__decrypt_key_127_96_vp_t (base_addr + 0x58/4);
        decrypt_key_95_64 = new csr__cryptokey_table__entry__decrypt_key_95_64_vp_t (base_addr + 0x5c/4);
        decrypt_key_63_32 = new csr__cryptokey_table__entry__decrypt_key_63_32_vp_t (base_addr + 0x60/4);
        decrypt_key_31_0 = new csr__cryptokey_table__entry__decrypt_key_31_0_vp_t (base_addr + 0x64/4);
        send_cnt_63_32 = new csr__cryptokey_table__entry__send_cnt_63_32_vp_t (base_addr + 0x68/4);
        send_cnt_31_0 = new csr__cryptokey_table__entry__send_cnt_31_0_vp_t (base_addr + 0x6c/4);
        recv_cnt_63_32 = new csr__cryptokey_table__entry__recv_cnt_63_32_vp_t (base_addr + 0x70/4);
        recv_cnt_31_0 = new csr__cryptokey_table__entry__recv_cnt_31_0_vp_t (base_addr + 0x74/4);
    };

    csr__cryptokey_table__entry__local_mac_47_32_vp_t* local_mac_47_32;
    csr__cryptokey_table__entry__local_mac_31_0_vp_t* local_mac_31_0;
    csr__cryptokey_table__entry__local_ip_vp_t* local_ip;
    csr__cryptokey_table__entry__local_port_vp_t* local_port;
    csr__cryptokey_table__entry__local_id_vp_t* local_id;
    csr__cryptokey_table__entry__remote_mac_47_32_vp_t* remote_mac_47_32;
    csr__cryptokey_table__entry__remote_mac_31_0_vp_t* remote_mac_31_0;
    csr__cryptokey_table__entry__remote_ip_vp_t* remote_ip;
    csr__cryptokey_table__entry__remote_port_vp_t* remote_port;
    csr__cryptokey_table__entry__remote_id_vp_t* remote_id;
    csr__cryptokey_table__entry__encrypt_key_255_224_vp_t* encrypt_key_255_224;
    csr__cryptokey_table__entry__encrypt_key_223_192_vp_t* encrypt_key_223_192;
    csr__cryptokey_table__entry__encrypt_key_191_160_vp_t* encrypt_key_191_160;
    csr__cryptokey_table__entry__encrypt_key_159_128_vp_t* encrypt_key_159_128;
    csr__cryptokey_table__entry__encrypt_key_127_96_vp_t* encrypt_key_127_96;
    csr__cryptokey_table__entry__encrypt_key_95_64_vp_t* encrypt_key_95_64;
    csr__cryptokey_table__entry__encrypt_key_63_32_vp_t* encrypt_key_63_32;
    csr__cryptokey_table__entry__encrypt_key_31_0_vp_t* encrypt_key_31_0;
    csr__cryptokey_table__entry__decrypt_key_255_224_vp_t* decrypt_key_255_224;
    csr__cryptokey_table__entry__decrypt_key_223_192_vp_t* decrypt_key_223_192;
    csr__cryptokey_table__entry__decrypt_key_191_160_vp_t* decrypt_key_191_160;
    csr__cryptokey_table__entry__decrypt_key_159_128_vp_t* decrypt_key_159_128;
    csr__cryptokey_table__entry__decrypt_key_127_96_vp_t* decrypt_key_127_96;
    csr__cryptokey_table__entry__decrypt_key_95_64_vp_t* decrypt_key_95_64;
    csr__cryptokey_table__entry__decrypt_key_63_32_vp_t* decrypt_key_63_32;
    csr__cryptokey_table__entry__decrypt_key_31_0_vp_t* decrypt_key_31_0;
    csr__cryptokey_table__entry__send_cnt_63_32_vp_t* send_cnt_63_32;
    csr__cryptokey_table__entry__send_cnt_31_0_vp_t* send_cnt_31_0;
    csr__cryptokey_table__entry__recv_cnt_63_32_vp_t* recv_cnt_63_32;
    csr__cryptokey_table__entry__recv_cnt_31_0_vp_t* recv_cnt_31_0;
} ;

// -----------------------------------------------------
class csr__cryptokey_table_vp_t {
public:

    csr__cryptokey_table_vp_t(uint32_t* base_addr)
    {
        for(int idx = 0; idx < 64; idx++)
        {
            entry[idx] = new csr__cryptokey_table__entry_vp_t (base_addr + 0x0/4 + 
                                                                                   idx * sizeof(csr__cryptokey_table__entry_t)/4);
        };

    };

    csr__cryptokey_table__entry_vp_t* entry[64];
} ;

// -----------------------------------------------------
class csr_vp_t {
public:

    csr_vp_t(uint32_t* base_addr = (uint32_t*)0x20000000)
    {
        cpu_fifo = new csr__cpu_fifo_vp_t (base_addr + 0x0/4);
        uart = new csr__uart_vp_t (base_addr + 0x38/4);
        gpio = new csr__gpio_vp_t (base_addr + 0x48/4);
        for(int idx = 0; idx < 4; idx++)
        {
            ethernet[idx] = new csr__ethernet_vp_t (base_addr + 0x4c/4 + 
                                                                                   idx * sizeof(csr__ethernet_t)/4);
        };

        hw_id = new csr__hw_id_vp_t (base_addr + 0x7c/4);
        hw_version = new csr__hw_version_vp_t (base_addr + 0x80/4);
        dpe = new csr__dpe_vp_t (base_addr + 0x84/4);
        routing_table = new csr__routing_table_vp_t (base_addr + 0x400/4);
        cryptokey_table = new csr__cryptokey_table_vp_t (base_addr + 0x2000/4);
    };

    csr__cpu_fifo_vp_t* cpu_fifo;
    csr__uart_vp_t* uart;
    csr__gpio_vp_t* gpio;
    csr__ethernet_vp_t* ethernet[4];
    csr__hw_id_vp_t* hw_id;
    csr__hw_version_vp_t* hw_version;
    csr__dpe_vp_t* dpe;
    csr__routing_table_vp_t* routing_table;
    csr__cryptokey_table_vp_t* cryptokey_table;
} ;


#endif
