// Generated by PeakRDL-regblock - A free and open-source SystemVerilog generator
//  https://github.com/SystemRDL/PeakRDL-regblock

module csr (
        input wire clk,
        input wire rst,

        input wire s_cpuif_req,
        input wire s_cpuif_req_is_wr,
        input wire [9:0] s_cpuif_addr,
        input wire [31:0] s_cpuif_wr_data,
        input wire [31:0] s_cpuif_wr_biten,
        output wire s_cpuif_req_stall_wr,
        output wire s_cpuif_req_stall_rd,
        output wire s_cpuif_rd_ack,
        output wire s_cpuif_rd_err,
        output wire [31:0] s_cpuif_rd_data,
        output wire s_cpuif_wr_ack,
        output wire s_cpuif_wr_err

        //input csr_pkg::csr__in_t hwif_in,
        //output csr_pkg::csr__out_t hwif_out
    );

    wire csr_pkg::csr__in_t hwif_in;
    wire csr_pkg::csr__out_t hwif_out;
    //--------------------------------------------------------------------------
    // CPU Bus interface logic
    //--------------------------------------------------------------------------
    logic cpuif_req;
    logic cpuif_req_is_wr;
    logic [9:0] cpuif_addr;
    logic [31:0] cpuif_wr_data;
    logic [31:0] cpuif_wr_biten;
    logic cpuif_req_stall_wr;
    logic cpuif_req_stall_rd;

    logic cpuif_rd_ack;
    logic cpuif_rd_err;
    logic [31:0] cpuif_rd_data;

    logic cpuif_wr_ack;
    logic cpuif_wr_err;

    assign cpuif_req = s_cpuif_req;
    assign cpuif_req_is_wr = s_cpuif_req_is_wr;
    assign cpuif_addr = s_cpuif_addr;
    assign cpuif_wr_data = s_cpuif_wr_data;
    assign cpuif_wr_biten = s_cpuif_wr_biten;
    assign s_cpuif_req_stall_wr = cpuif_req_stall_wr;
    assign s_cpuif_req_stall_rd = cpuif_req_stall_rd;
    assign s_cpuif_rd_ack = cpuif_rd_ack;
    assign s_cpuif_rd_err = cpuif_rd_err;
    assign s_cpuif_rd_data = cpuif_rd_data;
    assign s_cpuif_wr_ack = cpuif_wr_ack;
    assign s_cpuif_wr_err = cpuif_wr_err;

    logic cpuif_req_masked;

    // Read & write latencies are balanced. Stalls not required
    assign cpuif_req_stall_rd = '0;
    assign cpuif_req_stall_wr = '0;
    assign cpuif_req_masked = cpuif_req
                            & !(!cpuif_req_is_wr & cpuif_req_stall_rd)
                            & !(cpuif_req_is_wr & cpuif_req_stall_wr);

    //--------------------------------------------------------------------------
    // Address Decode
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                logic [1:0] allowed_ip[2];
                logic public_key;
                logic [1:0] endpoint;
            } table_[16];
            logic control;
        } ip_lookup_engine;
    } decoded_reg_strb_t;
    decoded_reg_strb_t decoded_reg_strb;
    logic decoded_req;
    logic decoded_req_is_wr;
    logic [31:0] decoded_wr_data;
    logic [31:0] decoded_wr_biten;

    always_comb begin
        for(int i0=0; i0<16; i0++) begin
            for(int i1=0; i1<2; i1++) begin
                decoded_reg_strb.ip_lookup_engine.table_[i0].allowed_ip[i1][0] = cpuif_req_masked & (cpuif_addr == 10'h0 + i0*10'h20 + i1*10'h8);
                decoded_reg_strb.ip_lookup_engine.table_[i0].allowed_ip[i1][1] = cpuif_req_masked & (cpuif_addr == 10'h4 + i0*10'h20 + i1*10'h8);
            end
            decoded_reg_strb.ip_lookup_engine.table_[i0].public_key = cpuif_req_masked & (cpuif_addr == 10'h10 + i0*10'h20);
            decoded_reg_strb.ip_lookup_engine.table_[i0].endpoint[0] = cpuif_req_masked & (cpuif_addr == 10'h18 + i0*10'h20);
            decoded_reg_strb.ip_lookup_engine.table_[i0].endpoint[1] = cpuif_req_masked & (cpuif_addr == 10'h1c + i0*10'h20);
        end
        decoded_reg_strb.ip_lookup_engine.control = cpuif_req_masked & (cpuif_addr == 10'h200);
    end

    // Pass down signals to next stage
    assign decoded_req = cpuif_req_masked;
    assign decoded_req_is_wr = cpuif_req_is_wr;
    assign decoded_wr_data = cpuif_wr_data;
    assign decoded_wr_biten = cpuif_wr_biten;


    //--------------------------------------------------------------------------
    // Write double-buffers
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                struct {
                    logic [63:0] data;
                    logic [63:0] biten;
                    logic pending;
                } allowed_ip[2];
                struct {
                    logic [31:0] data;
                    logic [31:0] biten;
                    logic pending;
                } public_key;
                struct {
                    logic [63:0] data;
                    logic [63:0] biten;
                    logic pending;
                } endpoint;
            } table_[16];
        } ip_lookup_engine;
    } wbuf_storage_t;
    wbuf_storage_t wbuf_storage;

    for(genvar i0=0; i0<16; i0++) begin
        for(genvar i1=0; i1<2; i1++) begin
            always_ff @(posedge clk) begin
                if(rst) begin
                    wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].pending <= '0;
                    wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].data <= '0;
                    wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].biten <= '0;
                end else begin
                    if(decoded_reg_strb.ip_lookup_engine.control && decoded_req_is_wr) begin
                        wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].pending <= '0;
                        wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].data <= '0;
                        wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].biten <= '0;
                    end
                    if(decoded_reg_strb.ip_lookup_engine.table_[i0].allowed_ip[i1][0] && decoded_req_is_wr) begin
                        wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].pending <= '1;
                        wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].data[31:0] <= (wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].data[31:0] & ~decoded_wr_biten) | (decoded_wr_data & decoded_wr_biten);
                        wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].biten[31:0] <= wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].biten[31:0] | decoded_wr_biten;
                    end
                    if(decoded_reg_strb.ip_lookup_engine.table_[i0].allowed_ip[i1][1] && decoded_req_is_wr) begin
                        wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].pending <= '1;
                        wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].data[63:32] <= (wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].data[63:32] & ~decoded_wr_biten) | (decoded_wr_data & decoded_wr_biten);
                        wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].biten[63:32] <= wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].biten[63:32] | decoded_wr_biten;
                    end
                end
            end
        end
        always_ff @(posedge clk) begin
            if(rst) begin
                wbuf_storage.ip_lookup_engine.table_[i0].public_key.pending <= '0;
                wbuf_storage.ip_lookup_engine.table_[i0].public_key.data <= '0;
                wbuf_storage.ip_lookup_engine.table_[i0].public_key.biten <= '0;
            end else begin
                if(decoded_reg_strb.ip_lookup_engine.control && decoded_req_is_wr) begin
                    wbuf_storage.ip_lookup_engine.table_[i0].public_key.pending <= '0;
                    wbuf_storage.ip_lookup_engine.table_[i0].public_key.data <= '0;
                    wbuf_storage.ip_lookup_engine.table_[i0].public_key.biten <= '0;
                end
                if(decoded_reg_strb.ip_lookup_engine.table_[i0].public_key && decoded_req_is_wr) begin
                    wbuf_storage.ip_lookup_engine.table_[i0].public_key.pending <= '1;
                    wbuf_storage.ip_lookup_engine.table_[i0].public_key.data <= (wbuf_storage.ip_lookup_engine.table_[i0].public_key.data & ~decoded_wr_biten) | (decoded_wr_data & decoded_wr_biten);
                    wbuf_storage.ip_lookup_engine.table_[i0].public_key.biten <= wbuf_storage.ip_lookup_engine.table_[i0].public_key.biten | decoded_wr_biten;
                end
            end
        end
        always_ff @(posedge clk) begin
            if(rst) begin
                wbuf_storage.ip_lookup_engine.table_[i0].endpoint.pending <= '0;
                wbuf_storage.ip_lookup_engine.table_[i0].endpoint.data <= '0;
                wbuf_storage.ip_lookup_engine.table_[i0].endpoint.biten <= '0;
            end else begin
                if(decoded_reg_strb.ip_lookup_engine.control && decoded_req_is_wr) begin
                    wbuf_storage.ip_lookup_engine.table_[i0].endpoint.pending <= '0;
                    wbuf_storage.ip_lookup_engine.table_[i0].endpoint.data <= '0;
                    wbuf_storage.ip_lookup_engine.table_[i0].endpoint.biten <= '0;
                end
                if(decoded_reg_strb.ip_lookup_engine.table_[i0].endpoint[0] && decoded_req_is_wr) begin
                    wbuf_storage.ip_lookup_engine.table_[i0].endpoint.pending <= '1;
                    wbuf_storage.ip_lookup_engine.table_[i0].endpoint.data[31:0] <= (wbuf_storage.ip_lookup_engine.table_[i0].endpoint.data[31:0] & ~decoded_wr_biten) | (decoded_wr_data & decoded_wr_biten);
                    wbuf_storage.ip_lookup_engine.table_[i0].endpoint.biten[31:0] <= wbuf_storage.ip_lookup_engine.table_[i0].endpoint.biten[31:0] | decoded_wr_biten;
                end
                if(decoded_reg_strb.ip_lookup_engine.table_[i0].endpoint[1] && decoded_req_is_wr) begin
                    wbuf_storage.ip_lookup_engine.table_[i0].endpoint.pending <= '1;
                    wbuf_storage.ip_lookup_engine.table_[i0].endpoint.data[63:32] <= (wbuf_storage.ip_lookup_engine.table_[i0].endpoint.data[63:32] & ~decoded_wr_biten) | (decoded_wr_data & decoded_wr_biten);
                    wbuf_storage.ip_lookup_engine.table_[i0].endpoint.biten[63:32] <= wbuf_storage.ip_lookup_engine.table_[i0].endpoint.biten[63:32] | decoded_wr_biten;
                end
            end
        end
    end
    //--------------------------------------------------------------------------
    // Field logic
    //--------------------------------------------------------------------------
    typedef struct {
        struct {
            struct {
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } address;
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } mask;
                } allowed_ip[2];
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } key;
                } public_key;
                struct {
                    struct {
                        logic [31:0] next;
                        logic load_next;
                    } address;
                    struct {
                        logic [15:0] next;
                        logic load_next;
                    } port;
                    struct {
                        logic [2:0] next;
                        logic load_next;
                    } interface_;
                } endpoint;
            } table_[16];
            struct {
                struct {
                    logic next;
                    logic load_next;
                } update;
            } control;
        } ip_lookup_engine;
    } field_combo_t;
    field_combo_t field_combo;

    typedef struct {
        struct {
            struct {
                struct {
                    struct {
                        logic [31:0] value;
                    } address;
                    struct {
                        logic [31:0] value;
                    } mask;
                } allowed_ip[2];
                struct {
                    struct {
                        logic [31:0] value;
                    } key;
                } public_key;
                struct {
                    struct {
                        logic [31:0] value;
                    } address;
                    struct {
                        logic [15:0] value;
                    } port;
                    struct {
                        logic [2:0] value;
                    } interface_;
                } endpoint;
            } table_[16];
            struct {
                struct {
                    logic value;
                } update;
            } control;
        } ip_lookup_engine;
    } field_storage_t;
    field_storage_t field_storage;

    for(genvar i0=0; i0<16; i0++) begin
        for(genvar i1=0; i1<2; i1++) begin
            // Field: csr.ip_lookup_engine.table[].allowed_ip[].address
            always_comb begin
                automatic logic [31:0] next_c;
                automatic logic load_next_c;
                next_c = field_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].address.value;
                load_next_c = '0;
                if(wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].pending && decoded_reg_strb.ip_lookup_engine.control && decoded_req_is_wr) begin // SW write
                    next_c = (field_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].address.value & ~wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].biten[31:0]) | (wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].data[31:0] & wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].biten[31:0]);
                    load_next_c = '1;
                end
                field_combo.ip_lookup_engine.table_[i0].allowed_ip[i1].address.next = next_c;
                field_combo.ip_lookup_engine.table_[i0].allowed_ip[i1].address.load_next = load_next_c;
            end

            always_ff @(posedge clk) begin
                if(field_combo.ip_lookup_engine.table_[i0].allowed_ip[i1].address.load_next) begin
                    field_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].address.value <= field_combo.ip_lookup_engine.table_[i0].allowed_ip[i1].address.next;
                end
            end
            assign hwif_out.ip_lookup_engine.table_[i0].allowed_ip[i1].address.value = field_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].address.value;
            // Field: csr.ip_lookup_engine.table[].allowed_ip[].mask
            always_comb begin
                automatic logic [31:0] next_c;
                automatic logic load_next_c;
                next_c = field_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].mask.value;
                load_next_c = '0;
                if(wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].pending && decoded_reg_strb.ip_lookup_engine.control && decoded_req_is_wr) begin // SW write
                    next_c = (field_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].mask.value & ~wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].biten[63:32]) | (wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].data[63:32] & wbuf_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].biten[63:32]);
                    load_next_c = '1;
                end
                field_combo.ip_lookup_engine.table_[i0].allowed_ip[i1].mask.next = next_c;
                field_combo.ip_lookup_engine.table_[i0].allowed_ip[i1].mask.load_next = load_next_c;
            end

            always_ff @(posedge clk) begin
                if(field_combo.ip_lookup_engine.table_[i0].allowed_ip[i1].mask.load_next) begin
                    field_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].mask.value <= field_combo.ip_lookup_engine.table_[i0].allowed_ip[i1].mask.next;
                end
            end
            assign hwif_out.ip_lookup_engine.table_[i0].allowed_ip[i1].mask.value = field_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].mask.value;
        end
        // Field: csr.ip_lookup_engine.table[].public_key.key
        always_comb begin
            automatic logic [31:0] next_c;
            automatic logic load_next_c;
            next_c = field_storage.ip_lookup_engine.table_[i0].public_key.key.value;
            load_next_c = '0;
            if(wbuf_storage.ip_lookup_engine.table_[i0].public_key.pending && decoded_reg_strb.ip_lookup_engine.control && decoded_req_is_wr) begin // SW write
                next_c = (field_storage.ip_lookup_engine.table_[i0].public_key.key.value & ~wbuf_storage.ip_lookup_engine.table_[i0].public_key.biten[31:0]) | (wbuf_storage.ip_lookup_engine.table_[i0].public_key.data[31:0] & wbuf_storage.ip_lookup_engine.table_[i0].public_key.biten[31:0]);
                load_next_c = '1;
            end
            field_combo.ip_lookup_engine.table_[i0].public_key.key.next = next_c;
            field_combo.ip_lookup_engine.table_[i0].public_key.key.load_next = load_next_c;
        end

        always_ff @(posedge clk) begin
            if(field_combo.ip_lookup_engine.table_[i0].public_key.key.load_next) begin
                field_storage.ip_lookup_engine.table_[i0].public_key.key.value <= field_combo.ip_lookup_engine.table_[i0].public_key.key.next;
            end
        end
        assign hwif_out.ip_lookup_engine.table_[i0].public_key.key.value = field_storage.ip_lookup_engine.table_[i0].public_key.key.value;
        // Field: csr.ip_lookup_engine.table[].endpoint.address
        always_comb begin
            automatic logic [31:0] next_c;
            automatic logic load_next_c;
            next_c = field_storage.ip_lookup_engine.table_[i0].endpoint.address.value;
            load_next_c = '0;
            if(wbuf_storage.ip_lookup_engine.table_[i0].endpoint.pending && decoded_reg_strb.ip_lookup_engine.control && decoded_req_is_wr) begin // SW write
                next_c = (field_storage.ip_lookup_engine.table_[i0].endpoint.address.value & ~wbuf_storage.ip_lookup_engine.table_[i0].endpoint.biten[31:0]) | (wbuf_storage.ip_lookup_engine.table_[i0].endpoint.data[31:0] & wbuf_storage.ip_lookup_engine.table_[i0].endpoint.biten[31:0]);
                load_next_c = '1;
            end else if(hwif_in.ip_lookup_engine.table_[i0].endpoint.address.we) begin // HW Write - we
                next_c = hwif_in.ip_lookup_engine.table_[i0].endpoint.address.next;
                load_next_c = '1;
            end
            field_combo.ip_lookup_engine.table_[i0].endpoint.address.next = next_c;
            field_combo.ip_lookup_engine.table_[i0].endpoint.address.load_next = load_next_c;
        end

        always_ff @(posedge clk) begin
            if(field_combo.ip_lookup_engine.table_[i0].endpoint.address.load_next) begin
                field_storage.ip_lookup_engine.table_[i0].endpoint.address.value <= field_combo.ip_lookup_engine.table_[i0].endpoint.address.next;
            end
        end
        assign hwif_out.ip_lookup_engine.table_[i0].endpoint.address.value = field_storage.ip_lookup_engine.table_[i0].endpoint.address.value;
        // Field: csr.ip_lookup_engine.table[].endpoint.port
        always_comb begin
            automatic logic [15:0] next_c;
            automatic logic load_next_c;
            next_c = field_storage.ip_lookup_engine.table_[i0].endpoint.port.value;
            load_next_c = '0;
            if(wbuf_storage.ip_lookup_engine.table_[i0].endpoint.pending && decoded_reg_strb.ip_lookup_engine.control && decoded_req_is_wr) begin // SW write
                next_c = (field_storage.ip_lookup_engine.table_[i0].endpoint.port.value & ~wbuf_storage.ip_lookup_engine.table_[i0].endpoint.biten[47:32]) | (wbuf_storage.ip_lookup_engine.table_[i0].endpoint.data[47:32] & wbuf_storage.ip_lookup_engine.table_[i0].endpoint.biten[47:32]);
                load_next_c = '1;
            end else if(hwif_in.ip_lookup_engine.table_[i0].endpoint.port.we) begin // HW Write - we
                next_c = hwif_in.ip_lookup_engine.table_[i0].endpoint.port.next;
                load_next_c = '1;
            end
            field_combo.ip_lookup_engine.table_[i0].endpoint.port.next = next_c;
            field_combo.ip_lookup_engine.table_[i0].endpoint.port.load_next = load_next_c;
        end

        always_ff @(posedge clk) begin
            if(field_combo.ip_lookup_engine.table_[i0].endpoint.port.load_next) begin
                field_storage.ip_lookup_engine.table_[i0].endpoint.port.value <= field_combo.ip_lookup_engine.table_[i0].endpoint.port.next;
            end
        end
        assign hwif_out.ip_lookup_engine.table_[i0].endpoint.port.value = field_storage.ip_lookup_engine.table_[i0].endpoint.port.value;
        // Field: csr.ip_lookup_engine.table[].endpoint.interface
        always_comb begin
            automatic logic [2:0] next_c;
            automatic logic load_next_c;
            next_c = field_storage.ip_lookup_engine.table_[i0].endpoint.interface_.value;
            load_next_c = '0;
            if(wbuf_storage.ip_lookup_engine.table_[i0].endpoint.pending && decoded_reg_strb.ip_lookup_engine.control && decoded_req_is_wr) begin // SW write
                next_c = (field_storage.ip_lookup_engine.table_[i0].endpoint.interface_.value & ~wbuf_storage.ip_lookup_engine.table_[i0].endpoint.biten[50:48]) | (wbuf_storage.ip_lookup_engine.table_[i0].endpoint.data[50:48] & wbuf_storage.ip_lookup_engine.table_[i0].endpoint.biten[50:48]);
                load_next_c = '1;
            end else if(hwif_in.ip_lookup_engine.table_[i0].endpoint.interface_.we) begin // HW Write - we
                next_c = hwif_in.ip_lookup_engine.table_[i0].endpoint.interface_.next;
                load_next_c = '1;
            end
            field_combo.ip_lookup_engine.table_[i0].endpoint.interface_.next = next_c;
            field_combo.ip_lookup_engine.table_[i0].endpoint.interface_.load_next = load_next_c;
        end

        always_ff @(posedge clk) begin
            if(field_combo.ip_lookup_engine.table_[i0].endpoint.interface_.load_next) begin
                field_storage.ip_lookup_engine.table_[i0].endpoint.interface_.value <= field_combo.ip_lookup_engine.table_[i0].endpoint.interface_.next;
            end
        end
        assign hwif_out.ip_lookup_engine.table_[i0].endpoint.interface_.value = field_storage.ip_lookup_engine.table_[i0].endpoint.interface_.value;
    end
    // Field: csr.ip_lookup_engine.control.update
    always_comb begin
        automatic logic [0:0] next_c;
        automatic logic load_next_c;
        next_c = field_storage.ip_lookup_engine.control.update.value;
        load_next_c = '0;
        if(decoded_reg_strb.ip_lookup_engine.control && decoded_req_is_wr) begin // SW write
            next_c = (field_storage.ip_lookup_engine.control.update.value & ~decoded_wr_biten[0:0]) | (decoded_wr_data[0:0] & decoded_wr_biten[0:0]);
            load_next_c = '1;
        end else begin // singlepulse clears back to 0
            next_c = '0;
            load_next_c = '1;
        end
        field_combo.ip_lookup_engine.control.update.next = next_c;
        field_combo.ip_lookup_engine.control.update.load_next = load_next_c;
    end
    always_ff @(posedge clk) begin
        if(rst) begin
            field_storage.ip_lookup_engine.control.update.value <= 1'h0;
        end else if(field_combo.ip_lookup_engine.control.update.load_next) begin
            field_storage.ip_lookup_engine.control.update.value <= field_combo.ip_lookup_engine.control.update.next;
        end
    end
    assign hwif_out.ip_lookup_engine.control.update.value = field_storage.ip_lookup_engine.control.update.value;

    //--------------------------------------------------------------------------
    // Write response
    //--------------------------------------------------------------------------
    assign cpuif_wr_ack = decoded_req & decoded_req_is_wr;
    // Writes are always granted with no error response
    assign cpuif_wr_err = '0;

    //--------------------------------------------------------------------------
    // Readback
    //--------------------------------------------------------------------------

    logic readback_err;
    logic readback_done;
    logic [31:0] readback_data;

    // Assign readback values to a flattened array
    logic [31:0] readback_array[113];
    for(genvar i0=0; i0<16; i0++) begin
        for(genvar i1=0; i1<2; i1++) begin
            assign readback_array[i0*7 + i1*2 + 0][31:0] = (decoded_reg_strb.ip_lookup_engine.table_[i0].allowed_ip[i1][0] && !decoded_req_is_wr) ? field_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].address.value : '0;
            assign readback_array[i0*7 + i1*2 + 1][31:0] = (decoded_reg_strb.ip_lookup_engine.table_[i0].allowed_ip[i1][1] && !decoded_req_is_wr) ? field_storage.ip_lookup_engine.table_[i0].allowed_ip[i1].mask.value : '0;
        end
        assign readback_array[i0*7 + 4][31:0] = (decoded_reg_strb.ip_lookup_engine.table_[i0].public_key && !decoded_req_is_wr) ? field_storage.ip_lookup_engine.table_[i0].public_key.key.value : '0;
        assign readback_array[i0*7 + 5][31:0] = (decoded_reg_strb.ip_lookup_engine.table_[i0].endpoint[0] && !decoded_req_is_wr) ? field_storage.ip_lookup_engine.table_[i0].endpoint.address.value : '0;
        assign readback_array[i0*7 + 6][15:0] = (decoded_reg_strb.ip_lookup_engine.table_[i0].endpoint[1] && !decoded_req_is_wr) ? field_storage.ip_lookup_engine.table_[i0].endpoint.port.value : '0;
        assign readback_array[i0*7 + 6][18:16] = (decoded_reg_strb.ip_lookup_engine.table_[i0].endpoint[1] && !decoded_req_is_wr) ? field_storage.ip_lookup_engine.table_[i0].endpoint.interface_.value : '0;
        assign readback_array[i0*7 + 6][31:19] = '0;
    end
    assign readback_array[112][0:0] = (decoded_reg_strb.ip_lookup_engine.control && !decoded_req_is_wr) ? field_storage.ip_lookup_engine.control.update.value : '0;
    assign readback_array[112][31:1] = '0;

    // Reduce the array
    always_comb begin
        automatic logic [31:0] readback_data_var;
        readback_done = decoded_req & ~decoded_req_is_wr;
        readback_err = '0;
        readback_data_var = '0;
        for(int i=0; i<113; i++) readback_data_var |= readback_array[i];
        readback_data = readback_data_var;
    end

    assign cpuif_rd_ack = readback_done;
    assign cpuif_rd_data = readback_data;
    assign cpuif_rd_err = readback_err;
endmodule
